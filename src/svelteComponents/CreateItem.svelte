<script lang="ts">
  import Dialog from "../svelteComponents/Dialog.svelte";
  import InfoToolTip from "./InfoToolTip.svelte";
  import { ip } from "../stores/ipStore.js";
  import CreateTemplate from "./CreateTemplate.svelte";
  import { actionStore } from "../stores/actionStore.js";
  import { SlideToggle } from "@skeletonlabs/skeleton";
  import CustomFieldPicker from "./CustomFieldPicker.svelte";
  import ImageSelector from './ImageSelector.svelte';

  import "../svelteStyles/main.css";
  import ActionDisplay from "./ActionDisplay.svelte";
  import type { IBasicItemPopulated } from "../models/basicItem.js";

  export let dialog: HTMLDialogElement;

  let templateDialog: HTMLDialogElement | undefined;

  export let curLocation : IBasicItemPopulated | null;

  let name = "";
  let description = "";
  let tags = "";
  let parentItemName = "";
  let parentItemId: string | null = null;
  let sameLocations: boolean = true;
  let parentItemSuggestions: any[] = [];
  let homeItemName = "";
  let homeItemId: string | null = null;
  if (curLocation != null) {
    homeItemName = curLocation.name;
    homeItemId = curLocation._id.toString();
  }
  let homeItemSuggestions: any[] = [];
  let templateName = "";
  let templateId: string | null = null;
  let templateSuggestions: any[] = [];
  let debounceTimeout: ReturnType<typeof setTimeout> | undefined;
  let selectedImage: File | null = null;
  let removeExistingImage = false;

  interface ICustomField {
    _id: string;
    fieldName: string;
    dataType: string;
    createdAt: string;
  }

  interface ICustomFieldEntry {
    fieldName: string;
    fieldId?: string;
    dataType: string;
    value: string;
    suggestions: ICustomField[];
    isNew: boolean;
    isSearching: boolean;
    isExisting: boolean;
    fromTemplate: boolean;
    searchTimeout?: ReturnType<typeof setTimeout>;
  }

  //Start with an empty array by default so no field loads initially
  let customFields: ICustomFieldEntry[] = [];

  let showCreateTemplateDialog = false;

  $: if (showCreateTemplateDialog) {
    if (templateDialog) {
      templateDialog.showModal();
    }
  }

  function resetForm() {
    name = "";
    description = "";
    tags = "";
    parentItemName = "";
    parentItemId = null;
    homeItemName = "";
    homeItemId = null;
    templateName = "";
    templateId = null;
    customFields = [];
    parentItemSuggestions = [];
    homeItemSuggestions = [];
    templateSuggestions = [];
    selectedImage = null;
    removeExistingImage = false;
  }
 
  async function handleCreateItem() {
    try {
      //If a template name is typed but not an exact match (no templateId set), block creation
      if (templateName.trim() && !templateId) {
        alert(
          "Please select a valid template from the list or clear the field.",
        );
        return;
      }

      const tagsArray = tags.split(",").map((tag) => tag.trim());

      if (sameLocations) {
        parentItemId = homeItemId;
        parentItemName = homeItemName;
      }

      //Filter out empty fields not from the template
      customFields = customFields.filter((field) => {
        if (field.fromTemplate) return true; //Always keep template fields that were loaded
        return field.fieldName.trim() !== "" && field.dataType.trim() !== "";
      });

      const formattedCustomFields = await Promise.all(
        customFields.map(async (field) => {
          if (!field.isNew && field.fieldId) {
            return { field: field.fieldId, value: field.value };
          } else {
            const createdField = await createCustomField(
              field.fieldName,
              field.dataType,
            );
            return { field: createdField._id, value: field.value };
          }
        }),
      );

      const formData = new FormData();
      formData.append("name", name);
      formData.append("description", description);
      formData.append("tags", JSON.stringify(tagsArray));
      if (parentItemId) formData.append("parentItem", parentItemId);
      if (homeItemId) formData.append("homeItem", homeItemId);
      if (templateId) formData.append("template", templateId);
      formData.append("customFields", JSON.stringify(formattedCustomFields));
      if (selectedImage) formData.append("image", selectedImage);

      console.log("Sending request with formData:");
      for (const pair of (formData as any).entries()) {
        console.log(pair[0], pair[1]);
      }

      const response = await fetch(`http://${$ip}/api/items`, {
        method: "POST",
        body: formData,
      });

      console.log("Response status:", response.status);
      console.log("Response headers:");
      response.headers.forEach((value, key) => {
        console.log(key, value);
      });

      // Try to get the raw text first
      const rawText = await response.text();
      console.log("Raw response:", rawText);

      // Then parse it as JSON
      const data = JSON.parse(rawText);

      if (!response.ok) {
        actionStore.addMessage("Error creating item");
        throw new Error(data.message || "Error creating item");
      }
      console.log("Item created:", data);
      actionStore.addMessage("Item created successfully!");
      dialog.close();
      location.reload();


      //Reset the form after successful creation
      resetForm();
    } catch (err) {
      console.error("Error creating item:", err);
      actionStore.addMessage("Error creating item");
    }
  }

  async function createCustomField(
    fieldName: string,
    dataType: string,
  ): Promise<ICustomField> {
    const response = await fetch(`http://${$ip}/api/customFields`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ fieldName, dataType }),
    });
    return await response.json();
  }

  //Parent item search handlers
  function handleParentItemInput(event: Event) {
    const target = event.target as HTMLInputElement;
    parentItemName = target.value;
    parentItemId = null;
    if (debounceTimeout) clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(() => {
      searchParentItems(parentItemName);
    }, 300);
  }

  async function searchParentItems(query: string) {
    try {
      const response = await fetch(
        `http://${$ip}/api/items/search?name=${encodeURIComponent(query)}`,
        {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        },
      );
      const data = await response.json();
      parentItemSuggestions = data;
    } catch (err) {
      console.error("Error searching parent items:", err);
    }
  }

  async function addToRecents(type: string, item: any) {
    console.log("DEBUG - addToRecents called with:", { type, item });
    try {
      const body = JSON.stringify({
        type,
        itemId: item._id,
      });
      console.log("DEBUG - Request body:", body);

      const response = await fetch(`http://${$ip}/api/recentItems/add`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: body,
      });

      const responseText = await response.text();

      if (!response.ok) {
        throw new Error(`Failed to add to recents: ${responseText}`);
      }
    } catch (err) {
      console.error("Error adding to recents:", err);
    }
  }

  function selectParentItem(item: { name: string; _id: string | null }) {
    parentItemName = item.name;
    parentItemId = item._id;
    parentItemSuggestions = [];
    if (item && item._id) {
      addToRecents("items", item);
    }
  }

  function selectHomeItem(item: { name: string; _id: string | null }) {
    homeItemName = item.name;
    homeItemId = item._id;
    homeItemSuggestions = [];
    if (item && item._id) {
      addToRecents("items", item);
    }
  }

  function selectTemplate(item: { name: string; _id: string }) {
    templateName = item.name;
    templateId = item._id;
    templateSuggestions = [];
    loadTemplateFields(templateId);
    if (item && item._id) {
      addToRecents("templates", item);
    }
  }

  async function loadTemplateFields(templateId: string | null) {
    if (!templateId) return;

    try {
      if (!templateName || templateName.trim() === "") {
        return;
      }

      console.log(
        `Fetching template details from: http://${$ip}/api/templates/${templateId}`,
      );
      const response = await fetch(
        `http://${$ip}/api/templates/${templateId}`,
        {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        },
      );

      if (!response.ok) {
        console.error(
          `Failed to fetch template. Status: ${response.status} - ${response.statusText}`,
        );
        console.error(await response.text());
        return;
      }

      const data = await response.json();
      console.log("Template data:", data);

      if (!data || !data.fields) {
        console.warn("No fields found in template:", data);
        return;
      }

      //Remove existing template fields before loading new ones
      removeTemplateFields();

      //Add the template fields
      console.log(`Fetching details for ${data.fields.length} fields.`);
      const templateFields = await Promise.all(
        data.fields.map(async (field: { _id: string }) => {
          const fieldId = field._id;
          const fieldUrl = `http://${$ip}/api/customFields/${fieldId}`;
          console.log(`Fetching field details from: ${fieldUrl}`);

          const fieldRes = await fetch(fieldUrl, {
            method: "GET",
            headers: { "Content-Type": "application/json" },
          });

          if (!fieldRes.ok) {
            console.error(
              `Failed to fetch field. Status: ${fieldRes.status} - ${fieldRes.statusText}`,
            );
            console.error(await fieldRes.text());
            throw new Error(`Failed to fetch field with ID: ${fieldId}`);
          }

          const fieldData: ICustomField = await fieldRes.json();
          console.log("Field data:", fieldData);

          return {
            fieldName: fieldData.fieldName,
            fieldId: fieldData._id,
            dataType: fieldData.dataType,
            value: "",
            suggestions: [],
            isNew: false,
            isSearching: false,
            isExisting: true,
            fromTemplate: true,
          };
        }),
      );

      console.log("Loaded template fields:", templateFields);

      //display template fields before any user-defined fields
      customFields = [...templateFields, ...customFields];
      console.log("Updated customFields:", customFields);
    } catch (err) {
      console.error("Error loading template fields:", err);
    }
  }

  //Removes all fields that came from a template
  function removeTemplateFields() {
    customFields = customFields.filter((f) => !f.fromTemplate);
  }

  //Custom fields handlers
  function onCustomFieldNameInput(index: number, event: Event) {
    const target = event.target as HTMLInputElement;
    customFields[index].fieldName = target.value;
    customFields[index].fieldId = undefined;
    customFields[index].isNew = true;
    customFields[index].isExisting = false;
    searchForCustomFields(index);
  }

  function searchForCustomFields(index: number) {
    if (customFields[index].searchTimeout)
      clearTimeout(customFields[index].searchTimeout);

    customFields[index].searchTimeout = setTimeout(async () => {
      const query = customFields[index].fieldName.trim();
      if (query.length === 0) {
        customFields[index].suggestions = [];
        return;
      }

      try {
        const response = await fetch(
          `http://${$ip}/api/customFields/search?fieldName=${encodeURIComponent(query)}`,
          {
            method: "GET",
            headers: { "Content-Type": "application/json" },
          },
        );
        const data: ICustomField[] = await response.json();
        customFields[index].suggestions = data;
      } catch (error) {
        console.error("Error searching custom fields:", error);
      }
    }, 300);
  }

  function selectCustomFieldSuggestion(
    index: number,
    suggestion: ICustomField,
  ) {
    customFields[index].fieldName = suggestion.fieldName;
    customFields[index].fieldId = suggestion._id;
    customFields[index].dataType = suggestion.dataType;
    customFields[index].isNew = false;
    customFields[index].isExisting = true;
    customFields[index].suggestions = [];
    if (suggestion && suggestion._id) {
      addToRecents("customFields", suggestion);
    }
  }

  function addCustomFieldLine() {
    customFields = [
      ...customFields,
      {
        fieldName: "",
        fieldId: undefined,
        dataType: "string",
        value: "",
        suggestions: [],
        isNew: true,
        isSearching: false,
        isExisting: false,
        fromTemplate: false,
      },
    ];
  }

  function removeCustomField(index: number) {
    // Only allow removing if not from template
    if (customFields[index].fromTemplate) return;
    customFields = customFields.filter((_, i) => i !== index);
  }

  function handleImageChange(event: CustomEvent) {
    const { selectedImage: newImage, removeExistingImage: remove } = event.detail;
    selectedImage = newImage;
    removeExistingImage = remove;
  }

  async function loadRecentItems(type: string) {
    try {
      const response = await fetch(`http://${$ip}/api/recentItems/${type}`, {
        method: "GET",
        headers: { "Content-Type": "application/json" },
      });
      const data = await response.json();
      return data;
    } catch (err) {
      console.error("Error loading recent items:", err);
      return [];
    }
  }

  async function handleParentItemFocus() {
    if (!parentItemName) {
      parentItemSuggestions = await loadRecentItems("items");
    }
  }

  async function handleHomeItemFocus() {
    if (!homeItemName) {
      homeItemSuggestions = await loadRecentItems("items");
    }
  }

  async function handleTemplateFocus() {
    if (!templateName) {
      templateSuggestions = await loadRecentItems("templates");
    }
  }

  async function handleCustomFieldFocus(index: number) {
    if (!customFields[index].fieldName) {
      customFields[index].suggestions = await loadRecentItems("customFields");
    }
  }

  async function handleCustomFieldClick(index: number) {
    if (!customFields[index].fieldName) {
      customFields[index].suggestions = await loadRecentItems("customFields");
    }
  }

  //Home item search handlers
  function handleHomeItemInput(event: Event) {
    const target = event.target as HTMLInputElement;
    homeItemName = target.value;
    homeItemId = null;
    if (debounceTimeout) clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(() => {
      searchHomeItems(homeItemName);
    }, 300);
  }

  function handleTemplateInput(event: Event) {
    const target = event.target as HTMLInputElement;
    templateName = target.value;
    templateId = null;
    if (debounceTimeout) clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(() => {
      searchTemplates(templateName);
    }, 300);
  }

  async function searchHomeItems(query: string) {
    try {
      const response = await fetch(
        `http://${$ip}/api/items/search?name=${encodeURIComponent(query)}`,
        {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        },
      );
      const data = await response.json();
      homeItemSuggestions = data;
    } catch (err) {
      console.error("Error searching home items:", err);
    }
  }

  async function searchTemplates(query: string) {
    try {
      const response = await fetch(
        `http://${$ip}/api/templates/searchTemplates?name=${encodeURIComponent(query)}`,
        {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        },
      );
      const data = await response.json();
      templateSuggestions = data;

      //Check for an exact match
      const exactMatch = data.find(
        (template: { name: string }) => template.name === templateName,
      );

      if (exactMatch) {
        if (templateId !== exactMatch._id) {
          templateId = exactMatch._id;
          await loadTemplateFields(templateId);
        }
      } else {
        templateId = null;
        removeTemplateFields();
      }
    } catch (err) {
      console.error("Error searching templates:", err);
    }
  }
</script>

{#if !showCreateTemplateDialog}
  <ActionDisplay />
{/if}

<Dialog bind:dialog on:close={resetForm}>
  <h1 id="underline-header" class="font-bold text-center">Create New Item</h1>
  <div class="page-component">
    <form on:submit|preventDefault={handleCreateItem}>
      <div class="flex flex-col space-y-4">
        <div class="flex flex-wrap space-x-4">
          <!-- Name -->
          <label class="flex-1 min-w-[200px]">
            Name (required):
            <input
              class="dark-textarea py-2 px-4 w-full"
              type="text"
              placeholder="Toolbox"
              bind:value={name}
              required
            />
          </label>

          <!-- Tags -->
          <label class="flex-1 min-w-[200px]">
            Tags:
            <textarea
              rows="1"
              id="resize-none-textarea"
              class="dark-textarea py-2 px-4 w-full"
              bind:value={tags}
            />
          </label>
        </div>

        <!-- Description -->
        <label class="min-w-[400px]">
          Description:
          <textarea
            rows="4"
            id="resize-none-textarea"
            class="dark-textarea py-2 px-4 w-full"
            placeholder="My medium-sized, red toolbox"
            bind:value={description}
          />
        </label>

        <div class="flex flex-col space-y-2">
            <ImageSelector 
              on:imageChange={handleImageChange}
            />
        </div>

        <SlideToggle
          name="slide"
          bind:checked={sameLocations}
          active="bg-green-700">Use same home and current location</SlideToggle
        >
        <div class="flex flex-wrap space-x-4">
          <!-- Parent Item -->
          {#if !sameLocations}
            <label class="flex-1 min-w-[200px] relative">
              Current Location:
              <InfoToolTip
                message="Where an item currently is, e.g. a shirt's parent item may be a suitcase."
              />
              
                <input
                type="text"
                class="dark-textarea py-2 px-4 w-full"
                bind:value={parentItemName}
                on:input={handleParentItemInput}
                on:focus={handleParentItemFocus}
                on:blur={() => (parentItemSuggestions = [])}
                />
            {#if parentItemSuggestions.length > 0}
              <ul class="suggestions">
                {#each parentItemSuggestions as item}
                  <button
                    class="suggestion-item"
                    type="button"
                    on:mousedown={(e) => {
                      e.preventDefault();
                      selectParentItem(item);
                    }}
                  >
                    {item.name}
                  </button>
                {/each}
              </ul>
            {/if}
          </label>
          {/if}

          <!-- Home Item -->
          <label class="flex-1 min-w-[200px] relative">
            Home Location:
            <InfoToolTip
              message="Where an item should normally be, e.g a shirt's home item may be a drawer."
            />
            <input
              type="text"
              class="dark-textarea py-2 px-4 w-full"
              bind:value={homeItemName}
              on:input={handleHomeItemInput}
              on:focus={handleHomeItemFocus}
              on:blur={() => (homeItemSuggestions = [])}
            />
            {#if homeItemSuggestions.length > 0}
              <ul class="suggestions">
                {#each homeItemSuggestions as item}
                  <button
                    class="suggestion-item"
                    type="button"
                    on:mousedown={(e) => {
                      e.preventDefault();
                      selectHomeItem(item);
                    }}
                  >
                    {item.name}
                  </button>
                {/each}
              </ul>
            {/if}
          </label>
        </div>

        <!-- Template Field and Create Template Button -->
        <div class="flex flex-wrap space-x-4 items-center">
          <label class="flex-1 min-w-[200px] relative">
            Template:
            <InfoToolTip
              message="A template is a more narrow category of similar items that share common fields. Select an existing template or create a new one."
            />
            <input
              type="text"
              class="dark-textarea py-2 px-4 w-full"
              bind:value={templateName}
              on:input={handleTemplateInput}
              on:focus={handleTemplateFocus}
              on:blur={() => (templateSuggestions = [])}
            />
            {#if templateSuggestions.length > 0}
              <ul class="suggestions">
                {#each templateSuggestions as t}
                  <button
                    class="suggestion-item"
                    type="button"
                    on:mousedown={(e) => {
                      e.preventDefault();
                      selectTemplate(t);
                    }}
                  >
                    {t.name}
                  </button>
                {/each}
              </ul>
            {/if}
          </label>
          <div>
            <br />
            <button
              type="button"
              class="border-button font-semibold shadow"
              on:click={() => (showCreateTemplateDialog = true)}
            >
              Create New Template
            </button>
          </div>
        </div>
      </div>

      <!-- Custom Fields -->
      <h2 class="font-bold text-lg mt-4">Custom Fields</h2>
      <div class="space-y-2">
        {#each customFields as field, index}
          <div class="field-row">
            <CustomFieldPicker
              bind:field={field}
              onFieldNameInput={(e) => onCustomFieldNameInput(index, e)}
              onFieldFocus={() => handleCustomFieldFocus(index)}
              onFieldBlur={() => (customFields[index].suggestions = [])}
              showDeleteButton={!field.fromTemplate}
              onDelete={() => removeCustomField(index)}
            >
              <svelte:fragment slot="suggestions">
                {#each field.suggestions as suggestion}
                  <button
                    class="suggestion-item"
                    type="button"
                    on:mousedown={(e) => {
                      e.preventDefault();
                      selectCustomFieldSuggestion(index, suggestion);
                    }}
                  >
                    {suggestion.fieldName} ({suggestion.dataType})
                  </button>
                {/each}
              </svelte:fragment>
            </CustomFieldPicker>
          </div>
        {/each}
      </div>

      <button
        type="button"
        class="border-button font-semibold shadow mt-2"
        on:click={addCustomFieldLine}
      >
        Add Custom Field
      </button>
      <!-- Submit -->
      <button
        class="border-button font-semibold shadow mt-4 block"
        type="submit"
      >
        Create Item
      </button>
    </form>
  </div>
</Dialog>

<!-- Create Template Dialog -->
{#if showCreateTemplateDialog}
  <Dialog
    bind:dialog={templateDialog}
    on:close={() => {
      showCreateTemplateDialog = false;
    }}
  >
    <CreateTemplate
      on:close={() => {
        showCreateTemplateDialog = false;
      }}
    />
  </Dialog>
{/if}
